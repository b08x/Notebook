
```
good evening my name is Kyle Jensen I'm on the faculty here at the Yale School of Management and I'm also the director of entrepreneurial programs here our guest tonight is Robert Martin who's going to talk about solid principles of object-oriented and natural design and we are very lucky to have him here it comes at a he's here at a great time for Yale as you may know the university is investing a great deal in entrepreneurship and that is creating I think or mixing with the university's traditional expertise and let's say computer science and the theory side and producing all sorts of great things on campus so for example two years ago why I started the tech bootcamp and hack Yale started a year ago why HACC brought together a thousand developers from around the country for a two-day hackathon this semester Daniel body changed the introduction to programming course here which is the kind of core programming course for non-majors to be mobile application development and Daniel and I are teaching together next to Europe in the spring computer science 113 which is entrepreneurship and programming and we have a course on management of software development here at the Yale School of Management so this is to say that there's a great interest at Yale in software development and and it transcends a couple different disciplines so it's here at the school of management's and the department of computer science it's and school of engineering and all sorts of places and across different clubs so organizations like they yell in entrepreneurial institute hack Yale entrepreneurship Club here I tsy hack all these kinds of organizations and it's not just yell so there's a couple logos up there that are I think that are not at Yale but an indicative of the activity in this space in the local community so we have to thank for the food tonight to continuity control which is local startup and Ruby shops filled with wonderful hackers and developers who are very active in New Haven IO which is a local developer group that I've been honored to be a part of and I worked with Dan and Joel and many other people who are here to organize a variety of ents for New Haven IO and I'm very happy to say that the plurality of people here tonight are actually probably not not from Yale which i think is really important because traditionally Yale has this kind of town and gown problem right where there's not much there's not much interaction and I think that's a real problem I think this is an area in which we have everybody has a mutual interest and excitement and so it's wonderful to have events like this and we're very happy to have Bob here to speak to us so I'm gonna invite Dan to come up and introduce himself and why I guess you don't need to introduce yourself you should introduce Bob but Dan I will introduce you so Dan is the Andaz developer at continuity control he has been an organizer of the local ruby group for many years and organizer at New Haven IO I think he's on the board of New Haven IO he is essentially you know very active local developer very supportive of the local community and I think that's wonderful and that's how our friendship has grown in that context so Dan thank you any better all right I should just been projecting sorry all right Dan Bernie our continuity New Haven IO summary version all right so like I did say we are hiring and we all have little continuity lapel pins so we do some pretty interesting things we aim to have really clean code we have some really interesting projects coming up with machine learnings interesting stuff like that so we're hiring come talk to us software is making software is a it's a weird business it's a messy business those of you who are students may not have found this out yet because when it's just for fun it's a lot of fun but when it matters when when you have people paying you for the software that you're writing or people using your software or god forbid people whose lives depend on your software it's a weird business and sometimes you can feel kind of like you know we're a bunch of kids running around with our shoes untied and you're just hoping you don't fall down but luckily we have an uncle looking out for us giving us a kick in the butt every once in a while when we need it Uncle Bob has been doing quite a number of things over his career he he helped write and signed the agile manifesto which really helped the industry rethink the way it looks at working with business people and the way it plans software how much we can know about a piece of software before we built it and how wise it is to bet a lot on that he's helped us look at the way we organize our code like four all the way from down to like how do you name that variable and that method all the way up to how do you organize pieces of applications and making them talk to each other and we're going to talk tonight or he's going to talk tonight about a spot right in the middle about how you organize your objects and have them relate to each other and he's helped us understand new programming languages and why they matter and why they helped and he's been writing books about all these things along the way and speaking at events like this all around so we owe a lot to him he's raised the overall level of our field quite a lot and he's kind of journaled it all along the way so hope having built him up too much but with that Bob [Applause] alright let's see do I need to turn the switch on or do to the audio people have this going switch on yeah alright oh I talk quietly there how's that oh good ok how many of you have programmers look at that yeah programmers is there you're not you're what online product that's not a programmer no not okay all right all right most of you are you're not that's okay what's water what is water a naturally occurring substance good very general definition um soft or hard but water itself is soft it's the stuff in it that makes it hard what's the chemical formula h2o which means two hydrogen one oxygen and what does the molecule look like Mickey Mouse very good so a water molecule has a big oxygen atom and two hydrogen atoms just like Mickey Mouse the angle here if I remember correctly is a hundred and three degrees for quantum mechanical reasons having to do with God knows what why do these three atoms stick together now before you give me the cutting of the normal Antos covalent bond think about what what those atoms are that's a a proton for the hydrogen right with a positive charge and another proton for the other hydrogen with a positive charge and how many protons in the oxygen atom eight six eight eight it's eight eight protons in the center of the oxygen nucleus and then around those protons is this cloud of electrons one electron for the hydrogen one electron for the other hydrogen and eight for the oxygen and that cloud of electrons has a negative charge so these two these three atoms should repel each other because they're surrounded by negative charge why do they stick together what's holding them they share it's classic you know really sure what what do they share so let's look carefully now first of all if the temperature is low enough if these atoms aren't moving fast enough they do repel each other they're not going to get near each other you have to get them moving fast you have to get them to bump into each other and if you get them to bump into each other something really interesting happens which is this first of all you have positive charge here and you got a positive charge here and a positive charge here where do the electrons want to go they want to be as close to all those positive charges as they can get which happens to be right here so you get a preponderance of negative charge between the protons and the negative charge holds the protons together you just have to get them close enough and then they just kind of go slip and they snap together now you mentioned that they share well they do share why because there's some bizarre quantum mechanical effect that has to do with the Pauli exclusion principle which says that the outer shell of the oxygen atom can have as many as eight electrons in it it's only got six and the two electrons from the hydrogen's will just snap into place there that's not the reason they stick together they stick together because of this charge they will fit because of the quantum mechanical effect that is a covalent bond covalent bond happens when you manage to get the bulk of the negative charge to hold the positive charges together of course the electrons flit around here and it's a big probabilistic thing they're really all over the place but they will spend more time there and they hold the whole thing together now look at this I bisect the molecule cutting Mickey Mouse's head in half and where's most of the negative charge it's above the line the molecule does not have its charge evenly distributed it is more negative above the line it is more positive below the line the molecule has a dipole a charge across it across it my wife gets mad at me when I put the T on the end of a cross and what that means is is that the molecule wants to rotate and stick to anything that has a charge no matter what the charge is why does water stick to your hand why does water get wet because all the molecules rotate and find some little charge on your hand and they stick to it electrostatically why does water dissolve things because anything that has a little charge the water molecule will stick to why does water is why is water good for washing because it can stick to dirt who's done the cute little trick where you take a faucet and you take a really thin stream of water you have to get this as thin as you can get it but without drips it's got to be a nice thin stream of water and then you get a balloon and you rub the balloon on your head and you take the balloon and you put it there and the water just goes wee attracts the balloon attracts a lot who's done that one dazzle your children kids watch this of course it's not what we're supposed to be talking about is it so we'll have to abandon this interesting topic and talk about something more mundane the solid principles of agile and oo design and I can throw a whole bunch of other adjectives in there if you'd like what goes wrong with software how many of you have been a programmer for more than a year five years notice how that's half ten years notice how we've cut it in half again 15 years hmm half again why that interesting having what is the population of programmers how many programmers are in the world it's a lot and it depends on if you count the VBA programmers but it's a lab it's probably close to a hundred million depending on how you count I started programming over 40 years ago how many programmers were there in nineteen what was that 70 say well no more than five was probably more like 50,000 but it was 100 million and if you go back ten years before that 1960 how many programmers were in 1960 a couple of hundred in the world a couple of hundred right hardly any and they weren't even programmers they were hardware developers that got roped into writing code because nobody knew what the hell this stuff was you think about this this progression of time right we started with a few programmers in the 50s managed to get a few hundred in the 60s a few thousand in the 70s now we're close to a hundred million that is a geometric exponential got you to tell me the word increase it has a doubling rate and the doubling rate half to be five years every five years the population of programmers doubles which has an interesting implication half the programmers have less than five years experience and this has always been true old guys like me people wonder you know how come there aren't more older programmers they must all quit they must all go chicken farming or something we don't quit there just weren't a lot of us hmm we're still all here we're still writing code it's just that there were hardly any of us to begin with how do we deal with the fact in our industry that we are stuck in an exponential curve that guarantees perpetual inexperience half one half of the programmers will have less than five years experience and that's going to remain true until that exponential curve tapers off which probably will happen sometime in the next couple of years maybe a couple of decades but pretty soon how do we deal with that what is the problem with that whoo the problem with that well let me ask this question how many of you of the old guys have been slowed down by really bad code and the young guys don't have their hands in the air right how many of the young guys been slowed down by really bad code that you wrote yesterday yeah we know the bad code slows us down why did we write it why do we write the code that slows us down how much does it slow us down so just town a lot and every time we touch the modules we get slowed down again every time we touch the bad code it slows us down why do we write this stuff that slows us down and the answer to that is well we have to go fast I will leave you to deal with the logical inconsistency there my message to you today is you don't go fast by writing crap you don't go fast by rushing you don't go fast by tearing through the code and just making it work and releasing it as fast as you can you want to go fast you do a good job your grandmother told you this a long time ago right you want to go fast you go well you take your time you study the problem you move deliberately instead of instead of rapidly a programmer who goes fast programmer who is rushing like crazy is guaranteed to go slow a programmer who sits carefully and thinks about it and types a few characters and looks at the code and cleans it a little bit and does this and that and he'll go fast she/he doesn't matter imagine this you are having an out-of-body experience floating above an operating table where a surgeon is performing open-heart surgery upon you you're looking down at that surgeon as he is opening your chest and trying to repair the damage to your heart how would you like this surgeon to behave carefully deliberate now he's got a deadline literally alright but you hope even because of this deadline even in the face of this deadline you hope this surgeon is behaving carefully calmly deliberately following his or her disciplines going close to the book not exactly by the book but close to the book calmly asking for an instrument calmly doing a thing acting like the surgeon knows what they're doing you don't want the surgeon acting like the typical software developer think about that for a while what goes wrong with software well that's what goes wrong with it but we can be more specific what are the symptoms of bad software how do you know you have bad code what does it do to you other than the obvious thing of slowing you down how does it slow you down it's confusing okay fine you look at it and you go huh now that's bad cog did I not put that up there you look at the code and you go that's bad cooked because good code should explain what it's doing but good code you should look at it and you should go oh yeah oh yeah it should be boring you should read it and go perfectly obvious that's good code bad code you man what else is doing what happens when you modify bad code you break something that's how you know it's bad code if you modify something and that breaks something else the code is bad so one of the symptoms is called rigidity rigidity is when you touch the code and you must now modify massive amounts of other code to come back into consistency with this modification you made your boss comes to you one day and says can you fix this bug and you look at the bug report and you say huh I know exactly where this bug is you don't tell your boss that you just think to yourself I know exactly where this bug is I actually put it in the code yesterday and so you tell your boss three weeks because that's the minimum estimate you're not allowed to give an estimate less than six three weeks if you give an estimate less than three weeks all the other developers come to your cubicle with clubs boss goes away happy he got the minimum estimate he'll be back in three weeks now you go to the module because you know where this bug is you go to the module it's up on your screen you look at it for me to say yep there's the bug I know how to fix it Vinnie do you know wait a minute if I do that there's this other module over here that calls that function I'd better go check it you bring that module lovely oh man I'm gonna have to fill it with that a little bit it changes a little bit oh wait if I make that change there's these modules over here and now you begin to chase the tail through the code and the weeks go by two weeks three weeks four or five your boss comes back in says I thought you were gonna be done with this in three weeks I'll be done tomorrow I swear by the time you're done you have touched every module in the system your boss says what the heck took so long and you utter the immortal words of every software developer well I was a lot more complicated than I thought that is rigid code code that has dependencies that snake out in so many directions that you cannot make an isolated change without changing everything else around it bad dependencies systems that are coupled another symptom of bad code similar to that one is called fragility fragility is the tendency of the code to break in many places even when you only change it in one place you make one very simple change and a whole bunch of other things break but they break in parts of the code that have no relationship to what you changed you made a little change here and something over there doesn't work anymore you make a change to the way the salary for hourly employees is calculated just a little change made little change and now it won't print the report for the union boss he crashes when it prints that report why'd that happen this is fragile code fragile code breaks and bizarre and strange ways ways that you cannot predict you make a change over here something over that breaks you didn't predict it you don't know why it happened if to chase the bug around finally you realize oh yeah that function over there set a flag and that guy over there use that flag and uh your car has an electric window that doesn't work you take it to a mechanic mechanic looks at it for a while so yeah I can fix that you come back the next day mechanic proudly shows you the electric window working you think him you get in the car you turn it on the car won't start you're not going back to that mechanic that mechanics an idiot and that's what happens when managers and customers see software developers change one thing over here and some over there breaks nothing strikes more fear into the heart of a customer or a manager than that one because all of a sudden the managers and the customers who don't have any idea about the technology they believe these guys have lost control they begin to think that if they looked under the hood they tried crap they're right and they begin to suspect that maybe the quality of this product is not all that good at all they become afraid of letting you make changes as anybody worked at a company where the management finally said all right nobody changes that module right that module is too fragile every time you touch it something else wrong nobody touches that module that is the ultimate failure of a software developer when the business who is not technically competent since you're not touching that module third symptom of bad code your boss comes to you and and says you know that module you've got to write you know Jo over in that other group over there he wrote one just like it last year you should go talk to Jo and see if you can use some of his code oh you know Jo and you know the kind of code that Jo writes and you don't want to go over there and talk to Jo but your boss told you to do it so you go over there and you look and sure enough Jo's module does just what you need it to do but it does more than that it couples to some bizarre framework it uses some weird database and the more you look at it the more you realize that yes you could use Jo's code but the problems you would be bringing in are so severe that you finally saying that just be easier for me to write it myself the desirable parts of the code are so horribly coupled to the undesirable parts of the code that you cannot use the desirable parts of the code somewhere else Jo's code was crap how do we deal with this what is the common thread of all of those flaws well okay spaghetti is the word that we use to say well this codes all scrambled up but there's a more technical term coupling the reason the code is rigid is because the modules depend on each other in undesirable ways the reason that the the code is fragile is because the code depends on data structures in undesirable ways the reason that I cannot take the desirable parts of Jo's code and use them in my system is because Jo's code depends on other code in undesirable ways and the common thread there is coupling dependency it can be said and I think accurately that the bulk of software design is managing dependencies figuring out where to put code and cutting the dependencies so that the dependencies don't run in strange and bizarre directions how do you do that so there's two people in the world I want to talk to people who designed whiteboards you know chalk does not do this right we have space over here yeah chalk also does not do that let's say that I've got a main program and let's say that we are writing code in C circa 1971 okay I got a main program my main program calls some high-level functions high-level modules and those high level modules call middle level modules more than one there's a bunch of these middle level modules OOP oh sorry it's the high level ones that call the mid level once mm-hmm and the middle level ones call lower level modules and you can see that there is this lovely tree of function calls this is the procedure function call tree that every application has no matter what the application is every application has one of these we start at main and we explode downwards towards the lowest level functions in the system I'm the flow of control goes that way main calls high-level high-level calls mid-level mid-level calls low-level the flow of control goes downwards which of these modules knows about the other which of these modules knows about the others in fact let's make it simpler I have a module M I have another module n module M has a function named F M calls F within n which of these modules knows about the other flow of control goes that way M knows about N and how do we know that M knows about n ok if n changes M has to hmm that must mean that the compiler knows how does the compiler know that M depends on n there is a statement in the source code of M that says we're doing C now pounded glued n dot H if for the for Java it would be import n if it were dotnet it would be using n but whatever language it is the name n appears in M there is a source code dependency from M to n which I will draw with a red line notice that the source code dependency the red line and the flow of control the green line point in the same direction that's a universal in order for one module to call another you have to have one module know about the other so how do the source code dependencies run here in this procedure calling tree well they must go like this the high level modules know about the low level modules think about that for a minute wait a minute the high level modules know about the low level modules what rule does that violate inversion of something do you want your high level policy polluted with low level detail this is what makes code hard to read your reading code and you're trying to get the idea of what's happening at the high level and all of a sudden you're dealing with string buffers all right and you know we're down at some really low level concept we're trying to piece together what's really going on at the high level but we can't because our high level modules depend on low level modules which depend on even lower level modules imagine some module down here which has an extremely low level thing in it god knows what some low level variable that that we need to make a change to I make a change of that module who recompiles you have to follow the arrows back every module that depends on this low level module is gonna have to recompile and be redeployed a change to a detail effects high level policy and that's wrong if you think about that for any length of time you think that's insane I don't want details changing high level policy I want my PI level policy to be immune from details why does code get rigid because we've got all this coupling down towards detail why does code get fragile because I can make a little change down here and break a whole bunch of stuff up there why is it that I can't reuse a bit of high-level policy because it's tightly coupled all this low-level crap what so Elle objects what are objects what is object-oriented design what is oh oh why is oh oh part of every language that you work in nowadays who's working in Java some people good how about how about c-sharp mmm some more people Ruby rails on Rails yeah we're gonna talk about Rails what else what other languages do we have Python yes Ruby point out hmmm who object you see conquering the world with iPhone apps how old is objective-c when was it invented 1980 who invented it Brad Cox why did he invent it he was a small talk programmer somebody made him program in C he hated it he wrote a little preprocessor in front of C gave it some small talk attributes he called it Objective C he started his own company called it step stone he thought he was going to take over the world he did for several years this was the only option that C programmers had to do any kind of oo work and we all worked in Objective C frantically from 1980 to 1985 and then yarnís tirstrup came along and published this lovely book called the C++ programming language and it looked so much like Kern Han and Ritchie that all the C programmers dropped whatever they were doing and immediately adopted C++ and poor old StepStone went out of business and that language would be dead today were it not for an accident of history that accident history was Steve Jobs who decided he would hire a real businessman for Apple and who did he go get he got the CEO of Pepsi Cola John Sculley as if the CEO of PepsiCo knew anything about high-tech computer company what the CEO of Pepsi Cola did know was enough politics to get Steve Jobs fired Steve Jobs went away with a lot of money he had tons of money so he didn't really care he started a new company new company was called next this company sold hardware black computers very pretty I have one in my basement he hired a bunch of programmers who were out looking for jobs because their language had disappeared from out from underneath them to happen to be objective-c programmers and they wrote the operating system for the next machine the operating system was called next step the company was a terrible failure the Machine never did anything the software never went anywhere it didn't matter because Apple went back to Steve on their hands and knees is the police come back Steve this guy's killing us and Steve said fine but I'm bringing my team with me and Steve went back to Apple taking all these objective-c programmers with them and they started working on the iPod that's why you're programming in Objective C the worst possible language for an iPhone by the way you should not be working in that horrible language but okay that's the accident of history why is it that all these languages are all languages it didn't used to be that way right we used to all wrote work in Fortran or peel 1 or COBOL or C nobody knew about oh oh how come all our languages are now our languages what's so good about oh oh that they're all our languages now help us organize code how encapsulation bumbum encapsulation so three magic words encapsulation inheritance polymorphism those are the three magic words of oo every oo language has to be encapsulated inherited in polymorphic did we have encapsulation when we were programming in C do we have any old C programmers in there okay good sir did we have encapsulation we had perfect encapsulation in C all you had to do is forward declare your functions and your data structure so you didn't have to implement them you would forward declare them in a header file and then you would implement them in AC file your users would pound include your header file they could see nothing of your implementation perfect encapsulation there was no way any of your users could see any of your data values all they could see was your function signatures they could see the names of your data structures but none of the members inside your data structures absolutely perfect encapsulation objects completely screwed that up C++ came along and put all the variables in the header file what did that do Wow and all the variables were suddenly visible to everybody and in order to get that under control we had to invent these horrible hacky words public private protected terrible hacks ridiculous some kind of band-aid over the fact that we used to have perfect encapsulation but now we've got this messy approach of trying to point at certain variables and say well that one's public but that one's private but that one's protected oh and we'll invent other ones too that have no name oh oh did not give us encapsulation Oh a weakened encapsulation every object language out there weakens the encapsulation that we used to have so when people tell you that oo is an encapsulated language they are wrong it destroyed good encapsulation and replaced it with this horrible hacky thing of making the compiler check oh you're not allowed to touch that variable so I'm not even gonna respond to the encapsulation answer that is just not there we had encapsulation now we don't could you do inheritance and see yeah but it was hard well we had unions and it wasn't too hard to take too data structures and give them common elements and change them only at the end so the last few elements were different and then you could cast pointers from one to the other and pass them around inside functions just like polymorphic objects we used to do this all the time it's very common approach and C C++ made it a little more convenient but not a lot multiple inheritance was much more convenient in C++ that's why they took it away in Java why does Java not have multiple inheritance wait why does C sharp not have multiple inheritance because Java doesn't have it why does Java not have multiple inheritance the diamond problem and the diamond problem has been solved the diamond problem is simple you get a basically a derivative to base classes both those base classes have a common base class this is the deadly Diamond dove death and there's a huge ambiguity Rezound that we won't go into the details but why didn't they resolve it because it had been resolved many times before by many other languages why didn't Java resolve this to simplify the compiler this is my best guess they were too lazy to deal with it so they invented some horrible act called interface and they stuck back in the language instead then we all bow and revere the interface who interfaces are good interfaces are wonderful and interface is nothing but an abstract class with a bunch of abstract methods in it right it's not some special thing in fact the only special thing in Java about an interface is what you can't do to it you can't inherit multiple interfaces you can't inherit multiple classes into another class why because the only thing you're allowed to multiply inherit is interfaces a hack a lazy hack I shouldn't have done that they should have solved the problem instead of just throwing it out there and then what happened it went into a bunch of other languages you can tell the time enjoying myself here aren't you okay so we did have inheritance of a kind in C we were able to simulate it but it wasn't very convenient so what I'll do here is I will give C half credit I will give Oh Oh half credit for giving us a slightly more convenient inheritance Ruby programmers how much do you use inheritance yeah for what makes sense active record do you use use it for polymorphism do you need to use inheritance for duck types don't know in Ruby in Python dynamically typed languages you can have polymorphism without any inheritance in fact all all polymorphism in these languages comes without inheritance inheritance is not necessary what do you use inheritance for in a dynamically typed language is to inherit behavior and variables but not interface you get all the polymorphism you want for free in Java and.net and C++ we have to have inheritance to do polymorphism one of the weaknesses of these languages is that you have to use inheritance to get polymorphism okay which leaves us with the last of those three polymorphism did we have polymorphism and see Wow sorta sorta and see we could do this work copy a copy application in C we used integers for characters in early C while C equals get char not equal to EOF I think there's a parenthesis there good put char C the UNIX copy program vastly simplified what does that program do ooh you did a nasty it does but not exactly it copies from standard input to standard output getchar reads a character from standard input put char writes a character to standard output what is standard input it defaults to the keyboard but it does not have to be the keyboard it could be anything put char rights to standard output which is usually the terminal I use the word terminal shows how old I am but it doesn't have to be the terminal it could be anything those are polymorphic calls get sure and put our our polymorphic method calls on a class named file if you wish they're just like any other virtual function in C++ just like any other polymorphic function in Java I have a type hierarchy there every i/o every i/o driver is just another type I had perfect encapsulation in see I had reasonable inheritance and see I could get polymorphism in C ooh how did that polymorphism work how was it that the flow of control left get char and got into the keyboard driver how'd that happen no it's much more clever than that much more insidious every i/o driver had to have five magical functions every i/o driver had these five functions they all had the exact same signature read write open close seek if you wrote an i/o driver you had to implement those five functions and the five functions had to have the same signature you open close read write seek the operating system would take pointers to those functions and put them into a table and when you call get char it would go to the table for standard in and say where's the read function oh I'll call that read function not knowing what the read function was just knowing that it had the right signature C++ programmers what was that table it's a V table exactly the way C++ implements virtual functions Java programmers do you have pointers to functions no why not because you have polymorphism if you have polymorphism you don't need pointers to functions c-sharp programmers do you have pointers to functions you get those ugly delegate things but they're not quite pointers to functions no no you don't have pointers to functions C++ programmers do but they don't use them if they're seen Ruby programmers you have pointers to functions not really o languages do not need pointers to functions because oo languages are polymorphic and if you have polymorphic dispatch you do not need pointers to functions hmm we did not do polymorphism in C very much and the reason we didn't do it in C very much was because it was dangerous as hell if you created a table of function pointers you had to load that table and you had to make sure that everybody called the functions through that table and if anybody violated any of those rules you had a terrible problem on your hands so most of the time we did not have polymorphism in C or in any language prior to C++ when C++ came along all of a sudden we got cheap easy safe polymorphism and polymorphism is interesting because polymorphism allows you to do something with this that we couldn't do before let me draw it again here's our module M here's our module n it has a function named F the flow of control will go from n to n calling F but if I have polymorphism if I have an oo language I can do this I can put an interface here yes I know I'm using the interface my M method my M module can mention the name of that interface and use it to call F I will define f in here the N module will derive from that interface and notice what has happened to the compile time dependency it points against the flow of control this is what polymorphism gives you polymorphism gives you the ability to create one module calling another and yet have the compile time dependency point against the flow of control instead of with the flow of control and if you have that power then you can take any of these red arrows here and turn any one of them around you suddenly have absolute control over your dependency structure and if you have absolute control over your dependency structure you can avoid writing fragile rigid and non reusable modules you can get around what goes wrong with software by carefully deciding which direction the arrows between modules should point that's what oo is you may have heard that oo is modeling the real world nonsense you may have heard that oo is closer to the way we think these these things were made up by marketing people in order to sell the idea to executives who didn't know what the what the programs were oo is about managing dependencies by selectively rien vert inque dependencies in your architecture so that you can prevent rigidity fragility non reusability there are several principles that we can talk about that take advantage of this aspect of polymorphism of oo we're going to introduce a few of them here as long as we have time notice that I have not been using my slides but everything I was talking about was actually there okay the principles we're going to talk about are called the solid principles they're called the solid principles because the words happen to spell out the word solid which is not something I knew to begin with but someone pointed it out to me several years ago and said you know this spells solid and so I quickly changed it because it sounded like a great word to use for a bunch of principles the first of these principles is called the single responsibility principle the single responsibility principle says this a class should have only one reason to change it should have a single responsibility to change don't be confused about the word responsibility the word responsibility does not mean function does not mean what it does the word responsibility means change it has one reason to change look at that look at that class up there that employee class it has a number of methods on it calc pay report hours right employee and a calc pay calculates the pay of an employee it's a payroll application report hours generate some horrible report that the auditors will read from time to time about the employees and write employee is a database function that saves the employee to a database how many reasons does this class have to change how many changes could be requested how many sources of change are there now let's think about that if the calcanei and cost the company a million dollars which c-level executive would find out about it first would it be the CFO the CEO oh or the CTO it would be the CFO because he'd be the one looking at the in the books in the accounts and then he would go to the programmers and fire them if there were a bug in the report hours function which and it cost the company a million dollars which c-level executive would find out about it first the CFO the CEO or the CTO CEO oh because he controls the auditors who check the reports about what got work done and what got spent and he would go to the developers and fire them and if the database crashed destroying a million dollars worth of data assets because some programmers screwed up that right employee method which c-level executive would discover at first he's the CTO so I have three different c-level executives interested in these three functions if they don't work right each of them will be upset for different reasons and if they want changes if their particular organizations want change those changes will come from beneath those particular C levels a change to the database schema is going to come underneath the CTO some DBA is gonna want to change the schema forcing you to change this class if the report needs to change it'll be some auditor who wants to change he reports to the CEO oh and if the business rules for calculating pay change it'll be some accountant who works for the CFO and so this class has three different responsibilities it has responsibilities to three different actors three different people or three different organizations all at the same time is it possible for me to add a new feature to the report hours function and accidentally break the calc pay function it is well I'm not going to do that I'm not gonna put those three methods in my class because those three methods have differ reasons to change they change at different times for different reasons they change it based on the interest of different people in the organization so I'm going to separate those three methods and keep them out of the single class and you say well wait a minute I thought this was objects I thought objects were supposed to have the methods that make them work and yeah sure that's true but you'd also better protect yourself from those c-level guys who are going to come and fire you so what do we do how do we get those three methods into three different classes because I don't want them there there's a whole bunch of ways to do that you could do it this way if you can't do you could create an employee which has the Cal pay method you could create other classes like the report writer and the employee repository that that speak to the employee method and manage to do their jobs that's a possibility although I don't much like that because these guys now depend on that and if there were a change to Cal pay these guys would have to be changed they would have to be recompiled and redeployed I don't much care for that so maybe what we'll do is this maybe what we'll do is we'll create an interface named employee that has the at least one of these methods and then we will derive from that interface another one of these classes that implements calc pay maybe we could do that or gee maybe we could maybe we could have a single class that influenced all three methods but has three different base classes one with each of the methods that would be interesting although I don't know if it solves the problem or maybe what we could do is create three classes one with each method and put a facade object out here that delegates to them there's a million ways to to address this problem million ways to move around it the important part is don't put functions that change for different reasons in the same class what reason is the report hours function going to change for what reason will the report hours function changing yeah they want to report fractional hours in a different way they're not changing the substance of the report at all they're just changing the format they used to report fractional hours with a decimal point now they're going to report fractional hours with two numbers one for the number of hours one for the number of tenths without the dot anymore and they don't like the dot right you think these guys don't do things like that yeah we don't like that dot okay so you work in there and you change the dot you pull the dot out right and you break the Kalka pay method you don't want methods in a class in the same class if they change for wildly different reasons I don't want to expose the campaign method to the vagaries of the auditors who want to change the format of a report formatting should go in one place calculation should go in another database in another and if you've got some other concern put it in another don't mix concerns in your classes that's what the open closed principle the O in solid the open closed principle says this was invented by the way by Bertrand Meyer in 1988 and a lovely book called object-oriented software construction if you haven't read that book go we defined the first edition read the first edition the second edition is a thousand pages long no one can possibly read it the open closed principle says this a class or a module should be open for extension but closed for modification what does that mean it means you should be able to change what the module does without changing the module you should be able to change the behavior of the module without changing the module it should be open for extension so its behavior can be extended but closed for modification now this sounds oxymoronic it sounds impossible how the heck can you change the behavior of a module if you can't change the module but we do it all the time this module here this copy module I can change its behavior by writing a new IO driver I can write a new IO driver that reads characters from the optical character reader and my copy program can call that draw io driver do I have to recompile my copy program no I don't have to change it I don't have to recompile it I don't have to do anything to it and yet it can call the optical character reader the optical character reader driver is written long after the copy program was compiled and put on my computer but my program can still call it I can extend the copy program because I have polymorphic calls within it and I can implement those polymorphic calls anytime I want to in any interesting way I want to I can extend the copy program if you can conform to this principle then when you add a new feature to an application you should be able to do that by writing new code and not changing any old code you're not gonna modify it you're going to extend it so all your modules are closed for modification but they can be extended so you can extend your application with a new feature without changing any of the existing modules if you have conformed to that principle is this possible yeah that's possible I can do it here I'll show you it's easy will do this in C or some language that sort of looks like seeing I've got a simple application by the way this is the failing version this is the version that does not conform to the open closed principle written in C okay I've got some shape dots h-class it has an M in it that enum has two numerators Circle n square there is a data structure within it called shape which has one data element which is the enumeration I have another data structure called circle it begins the same way that shape does which means I can cast a circle to a shape and still use it this is kind of fake fake inheritance here I've got a double radius and a center point and a function that can draw a circle I've got a data structure named square and in another file called square dot H it also begins with the enum data structure has a double side and a top left point and a function that draws the square and now I have this function here draw all shapes draw all shapes takes an array of shape pointers it loops through the array of shape pointers it asks each shape what its type is if it's a square it calls draw square if it's a circle it calls draw circle what bad thing happens because I wrote the code this way this violates the open-closed principle so if I add an oval I must add another switch another case to the switch statement but that's not the first thing I did what's the first line of code that changes enum and that's in shape dot H who pound include shape dot H everybody who recompiles everybody circle recompiles because I added an oval square recompiles because I added an oval that's fundamentally sick right square and circle don't give a damn about oval but they've got to recompile just because I added an oval something's really wrong with that that's rigid that is the symptom of rigidity you have to compile too much because of a change to compile things that should not have had to be recompiled because of a change but it's worse than that because I do have to modify the switch statement I've got to go to the switch statement and I've got to add the Oh case and you think well that's not so bad it's just a switch daemon huh but there's more than one switch statement switch statements are like the sis always more than one there are switch statements replicate and duplicate and spread through the system there are switch statements of this form for draw all shapes erase all shapes drag all shapes scale all shapes rotate all shapes anything you can do with shapes there's a switch statement for it except that they're not all switch statements because some programmers don't like switch statements and they use if-else statements instead but they're still switch statements and now what I have to do is I have to find them all and I have to modify them all I have to put oval in all of them and that may seem simple except for the fact that programmers are strange beasts they like to do logical optimizations if they can get rid of a case or do some special ands and ORS or something they will do that for example what is the case of a circle in rotate all shapes nothing you don't do anything to a circle when you rotate it it doesn't have a case so this is fragile it's going to break because I'm not gonna find all of those switch statements and I'm not going to logically decode them properly and I will wind up creating some problem because I missed something this is rigid because it recompiles more than it ought to it is fragile because I can't possibly find all the switch statements and modify them correctly but that is not the worst of the problems is the worst of the problem is this our boss comes to us and says you know we've had a lot of trouble with this startup company and we're about to run out of funding the sales model we had just isn't working but we got a new idea hired a consultant paid him a lot of money and he told us what we had to do what we have to do is this we have to give away draw all shapes for free we're going to take that we're going to put it in a jar file or a DLL we're going to put it up on our website give it away for free and then are going to take all the circles and squares and ovals and triangles and we're going to put them in separate jar files or dll's and we'll sell them all for $5 each on our website and we have to tell our boss that we can't do that because the switch statement has a dependency on square and circle and oval and triangle we cannot separate them we must deploy circle and square and triangle and oval withdraw all shapes there's no way to independently deploy them and we tell our boss our architecture does not support what you want to do and then we go out of business and I look for other jobs that is immobile ax t the reusable part was not properly decoupled from the goop how can we fix that now are you ready for the Y hmm here comes the line this is the oo version and I want you to think of soft music in the background sound of wind blowing to the trees fuzzy bunnies jumping over hillsides class shape has a draw function this is C++ but don't let that worry you umm class square derives from shape it also has a draw function class circle derives from shape it also has a draw function and look at draw all shapes the elegance the glory the beauty of it all they're all shapes loops through the shapes and just tells each one to draw itself Oh God what happens when we add the oval what here must recompile nothing nothing I can add the oval nothing here recompiles open closed principle is it fragile it's not rigid now can't be rigid because nothing has to recompile is it fragile can't be fragile because everything I can do to a shape I must implement in that shape there's no way for me to forget to implement a method it's not fragile I don't have to go hunting for switch statements there's no funny logical optimizations the rotate function will be implemented to do at least something in circle even if it's just open closed brace it's not fragile but the best part is that when our boss comes to us and says yeah we want to put those shapes in one DLL and we want to put the draw shapes in another DLL we can do that because draw shapes doesn't have any idea that squares and circles exist the high-level policy here does not know about the low-level details the flow of control still works the same way this loop calls these draw functions but at compile time the high-level policy does not know about the low-level details and none of the design flaws appear none of the symptoms of bad code are evident I said this was the lie why is this the lie well it turns out that customers have a different idea in mind this protects us from something what does it protect us from what changes does it protect us from new if we make new shapes nothing here changes our customers have no interest in new shapes what they want is for all the squares to be drawn first and all the circles to be drawn second that's the change they want to make they want all these circles to be on top of the squares so they want the ordering to change now had we known that ahead of time maybe we could have invented an abstraction that protected us against the ordering of the shapes but we didn't know that ahead of time we thought this was a perfectly good real world model great squares derived from shape circle derives from shape how better could you model the real world than that it's just that's not what the customers care about customers are very good at somehow knowing what your design is and then choosing the new feature that will completely thwart your design this is a fact of life it's one of the great flaws of oo design because in order for oo designed to protect you from the customer you must know what the customer is going to do and customers always do the other thing so you can't just lively model the real world and hope for the best because the customers will certainly find some interesting way to screw you what we do instead is we take a very pragmatic view we say all right what we're gonna do is implement the simplest thing we possibly can and then we're going to get it out in front of the customer as soon as we possibly can and we're gonna ask the customer to change it please change our code have you ever done this please change our code give us new features and the customers will suggest new features and this gives you a clue about where the axis of change really is in your application and then you can implement the abstractions that protect you from those changes do not think that you know because you don't go out to the customers as early as you can find out what they're going to do to you and then build the abstractions into your application that will protect you and they won't be what you think they I think we have time for one more this is called the Liskov substitution principle it was invented by Barbara Liskov in 1988 1988 was a good year for principles Barbara Liskov said this well actually I this is a paraphrase because what she wrote was a mathematical formula but what I will do is paraphrase that formula derived classes must be usable through the base class interface without the need for the user to know the difference that makes perfect sense right I've got some user and the user uses a base class but I've got a derivative I should be able to substitute that derivative in and the client shouldn't know anything about it simple polymorphism right so the dreaded rectangle square problem I have a rectangle in this class we wrote a long time ago and it's got a field named height and a field named width they're both real numbers there's a set height and a set width function and a new requirement test come along that new requirement is for a square now clearly a square is a rectangle so Square inherits from rectangle makes perfect sense wait a minute how many fields does a rectangle have to rectangle to height and width how many fields does the square need one how many will it inherit something's wrong square cannot inherit from rectangle and only have one field now that means we're gonna waste memory memories cheap let's just waste the memory and do this let's override set width in square so that it sets both the height and the width and will override set height so that it sets both the height and the width that solves the problem imagine some user of rectangle that user calls set height does the user that calls set height on rectangle have the right to expect that the width won't change yes but if I pass him a square he will call set height and the width will change and that will corrupt his internal finite state machine and he will then corrupt the heap and he will discover this a billion instructions later when you get a nullpointerexception what happened oh by the way you're the guy right in the code that just blew up you're the guy right in the code that's calling set width on the rectangle and you get your logic analyzer out and you walk through the back trace through a billion instructions and you find after weeks of analysis that the reason you blew up is because somebody passed you a square so what code are you going to write in your module that will protect you from the possibility that the rectangle you're holding might actually be a square if the rectangle is a square and by doing so you will hang a dependency on the square something that you never wanted to know about but your module which was supposed to know about rectangles will suddenly have a dependency upon the square violating the open closed principle and making you rigid and making you fragile does anybody have any code like that in their system where you ask what type an object is what do we use in Java we use the instance of in dotnet we use is or as there's a bunch of different ways to do that it is not true that every time that you do that it's a problem but most of the when you do that it is a problem most of the time and this particular interesting relationship causes that to happen so what went wrong isn't a square a rectangle right a square is a rectangle so that should be the right relationship now because that's not a square that's a piece of code that is not a rectangle it is a piece of code it is true that a square is a rectangle but the class square is not a square the class rectangle is not a rectangle if the class square represents the square the class rectangle represents a rectangle but the representatives of things do not share the relationships of the things they represent if anybody here has been divorced you may have had two lawyers representing you and your spouse those two lawyers were probably not themselves getting divorced the things that represent do not share the relationships of the things they represent you cannot simply say well that class has the name of something and therefore I'm going to use an inheritance relationship you have to understand what these relationships are we we call that relationship Iza that's the wrong name for that it's not is a-- it got inherited from the artificial intelligence people in the 80s they they were doing interesting data structures called knowledge nets and they had interesting relationships has a taste like us smells like it is a-- and they all got fired because their funding dried up because artificial intelligence didn't actually do anything useful and so then they all became oo programmers and they carried their interesting abbreviations with them and that's how we got the has a-- and uses on is a relationships and they named these relationships that way but they're lies they're not correct the inheritance relationship is not the Izza relationship the inheritance relationship really is just the redecoration of functions and variables in a sub scope no and I know that's complicated to remind remember how can we fix this problem what is the relationship between square answer and rectangle they do they but yeah you'd want like I behaves like a thing what am I going to do am I going to have any relationship between these two classes at all they might both derive from a common base class maybe maybe the base class shape but these two classes really have nothing in common at all they don't have the same number of variables they don't have the same behavior they are not related at least not as siblings and certainly rectangle is not the parent of square this is a violation of the Liskov substitution principle because Square is not substitutable for rectangle even though it seems to fit the definition of ISA it does not fit the substitution rule and whenever you violate the substitution rule you will eventually add an if statement that checks the type of the object to prevent you from crashing your system which makes this about eight o'clock oh you want to continue you want a method is is regular mmm you want that up in rectangle and what you're saying is is it a regular rectangle so I don't even want to wait I don't want the square class I just want a regular now what would happen if I were then to set the height of a regular rectangle would it set the width would I modify the width would I dare or would I just set the is regular flag false if they happen to be the same do I automatically set the these regular flag ooh I calculated so is regular will return true if the height and width are the same okay there reals what can you not do with a real number you cannot compare them equal can I compare real numbers equal people go to jail for doing that by the way especially if the real number represents money do not compare real numbers equal in a computer floating-point numbers can be greater than or less but they are never equal and if you use the equal operator and it says they're equal it's a lie I cannot compare them equal you can compare them close but you can't compare you alright I think we're done for the day thank you all for your attention if there's any questions I'm gonna hang around for a little while but the rest of you can go
```